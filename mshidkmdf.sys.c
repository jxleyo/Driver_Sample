/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

NTSTATUS __fastcall HidKmdfPassThrough(__int64 a1, IRP *a2);
NTSTATUS __fastcall HidKmdfNotifyPresence(struct _DEVICE_OBJECT *a1, BOOLEAN a2);
NTSTATUS __fastcall HidKmdfPowerPassThrough(__int64 a1, IRP *a2);
void __cdecl __noreturn _report_gsfailure(uintptr_t StackCookie);
__int64 __fastcall _GSHandlerCheckCommon(__int64 a1, __int64 a2);
void *__cdecl memset(void *, int Val, size_t Size);
// NTSTATUS __stdcall HidNotifyPresence(PDEVICE_OBJECT DeviceObject, BOOLEAN IsPresent);
// NTSTATUS __stdcall HidRegisterMinidriver(PHID_MINIDRIVER_REGISTRATION MinidriverRegistration);
// BOOLEAN __stdcall IoForwardIrpSynchronously(PDEVICE_OBJECT DeviceObject, PIRP Irp);
// void __stdcall PoStartNextPowerIrp(PIRP Irp);
// void __stdcall __noreturn KeBugCheckEx(ULONG BugCheckCode, ULONG_PTR BugCheckParameter1, ULONG_PTR BugCheckParameter2, ULONG_PTR BugCheckParameter3, ULONG_PTR BugCheckParameter4);
// void __stdcall IoFreeIrp(PIRP Irp);
// NTSTATUS __stdcall IofCallDriver(PDEVICE_OBJECT DeviceObject, PIRP Irp);
// PIRP __stdcall IoAllocateIrp(CCHAR StackSize, BOOLEAN ChargeQuota);
// NTSTATUS __stdcall PoCallDriver(PDEVICE_OBJECT DeviceObject, PIRP Irp);
__int64 __fastcall HidKmdfAddDevice(__int64 a1, __int64 a2);
NTSTATUS __fastcall HidKmdfPnp(__int64 a1, IRP *a2);
__int64 __fastcall HidKmdfUnload(); // weak
NTSTATUS __stdcall DriverEntry(_DRIVER_OBJECT *DriverObject, PUNICODE_STRING RegistryPath);
NTSTATUS __stdcall GsDriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath);
// void __cdecl _security_init_cookie();

//-------------------------------------------------------------------------
// Data declarations

GUID GUID_WDF_HID_INTERFACE_STANDARD = { 4289533346u, 42744u, 20064u, { 153u, 199u, 43u, 146u, 98u, 77u, 220u, 37u } };
uintptr_t _security_cookie = 47936899621426ui64;
ULONG_PTR _security_cookie_complement = 18446696136809930189ui64; // idb


//----- (00000001C0001010) ----------------------------------------------------
NTSTATUS __fastcall HidKmdfPassThrough(__int64 a1, IRP *a2)
{
  struct _IO_STACK_LOCATION *v2; // rax

  v2 = a2->Tail.Overlay.CurrentStackLocation;
  *(_OWORD *)&v2[-1].MajorFunction = *(_OWORD *)&v2->MajorFunction;
  *(_OWORD *)&v2[-1].Parameters.NotifyDirectoryEx.CompletionFilter = *(_OWORD *)&v2->Parameters.NotifyDirectoryEx.CompletionFilter;
  *(_OWORD *)(&v2[-1].Parameters.SetQuota + 6) = *(_OWORD *)(&v2->Parameters.SetQuota + 6);
  v2[-1].FileObject = v2->FileObject;
  v2[-1].Control = 0;
  return IofCallDriver(*(PDEVICE_OBJECT *)(*(_QWORD *)(a1 + 64) + 8i64), a2);
}

//----- (00000001C0001060) ----------------------------------------------------
NTSTATUS __fastcall HidKmdfNotifyPresence(struct _DEVICE_OBJECT *a1, BOOLEAN a2)
{
  return HidNotifyPresence(a1, a2);
}

//----- (00000001C0001080) ----------------------------------------------------
NTSTATUS __fastcall HidKmdfPowerPassThrough(__int64 a1, IRP *a2)
{
  struct _IO_STACK_LOCATION *v4; // rax

  PoStartNextPowerIrp(a2);
  v4 = a2->Tail.Overlay.CurrentStackLocation;
  *(_OWORD *)&v4[-1].MajorFunction = *(_OWORD *)&v4->MajorFunction;
  *(_OWORD *)&v4[-1].Parameters.NotifyDirectoryEx.CompletionFilter = *(_OWORD *)&v4->Parameters.NotifyDirectoryEx.CompletionFilter;
  *(_OWORD *)(&v4[-1].Parameters.SetQuota + 6) = *(_OWORD *)(&v4->Parameters.SetQuota + 6);
  v4[-1].FileObject = v4->FileObject;
  v4[-1].Control = 0;
  return PoCallDriver(*(PDEVICE_OBJECT *)(*(_QWORD *)(a1 + 64) + 8i64), a2);
}

//----- (00000001C0001130) ----------------------------------------------------
void __cdecl __noreturn _report_gsfailure(uintptr_t StackCookie)
{
  KeBugCheckEx(0xF7u, StackCookie, _security_cookie, _security_cookie_complement, 0i64);
}

//----- (00000001C00011AC) ----------------------------------------------------
__int64 __fastcall _GSHandlerCheckCommon(__int64 a1, __int64 a2)
{
  __int64 result; // rax
  unsigned __int8 v3; // dl

  result = *(_QWORD *)(a2 + 8);
  v3 = *(_BYTE *)(*(unsigned int *)(*(_QWORD *)(a2 + 16) + 8i64) + result + 3);
  if ( (v3 & 0xF) != 0 )
    result = v3 & 0xF0;
  return result;
}

//----- (00000001C0001240) ----------------------------------------------------
void *__cdecl memset(void *a1, int Val, size_t Size)
{
  void *result; // rax
  __int64 v4; // rdx
  size_t v5; // r9
  char *v6; // rcx
  size_t v7; // r8
  size_t i; // r8
  __m128 v9; // xmm0
  char *v10; // r8
  __m128 *v11; // rcx
  unsigned __int64 v12; // r8
  unsigned __int64 v13; // r9
  unsigned __int64 j; // r9
  __int64 v15; // r8

  result = a1;
  if ( Size < 8 )
  {
    for ( i = Size & 7; i; --i )
      *((char *)a1 + i - 1) = Val;
  }
  else
  {
    v4 = 0x101010101010101i64 * (unsigned __int8)Val;
    if ( Size >= 0x4F )
    {
      v9 = _mm_movelh_ps((__m128)(unsigned __int64)v4, (__m128)(unsigned __int64)v4);
      *(__m128 *)a1 = v9;
      v10 = (char *)a1 + Size;
      v11 = (__m128 *)(((unsigned __int64)a1 + 16) & 0xFFFFFFFFFFFFFFF0ui64);
      v12 = v10 - (char *)v11;
      v13 = v12 >> 7;
      if ( v12 >> 7 )
      {
        do
        {
          *v11 = v9;
          v11[1] = v9;
          v11 += 8;
          v11[-6] = v9;
          v11[-5] = v9;
          --v13;
          v11[-4] = v9;
          v11[-3] = v9;
          v11[-2] = v9;
          v11[-1] = v9;
        }
        while ( v13 );
        v12 &= 0x7Fu;
      }
      for ( j = v12 >> 4; j; --j )
        *v11++ = v9;
      v15 = v12 & 0xF;
      if ( v15 )
        *(__m128 *)((char *)v11 + v15 - 16) = v9;
    }
    else
    {
      v5 = Size & 0xFFFFFFFFFFFFFFF8ui64;
      v6 = (char *)a1 + (Size & 0xFFFFFFFFFFFFFFF8ui64);
      do
      {
        *(_QWORD *)((char *)result + v5 - 8) = v4;
        v5 -= 8i64;
      }
      while ( v5 );
      v7 = Size & 7;
      if ( v7 )
        *(_QWORD *)&v6[v7 - 8] = v4;
    }
  }
  return result;
}

//----- (00000001C0006010) ----------------------------------------------------
__int64 __fastcall HidKmdfAddDevice(__int64 a1, __int64 a2)
{
  char *v3; // r14
  PIRP v4; // rax
  IRP *v5; // rsi
  struct _IO_STACK_LOCATION *v6; // rbx

  v3 = *(char **)(*(_QWORD *)(a2 + 64) + 16i64);
  *(_QWORD *)(v3 + 4) = 0i64;
  *(_QWORD *)(v3 + 12) = 0i64;
  *(_QWORD *)(v3 + 20) = 0i64;
  *((_DWORD *)v3 + 7) = 0;
  *((_QWORD *)v3 + 5) = a2;
  *(_DWORD *)v3 = 65584;
  *((_QWORD *)v3 + 4) = HidKmdfNotifyPresence;
  v4 = IoAllocateIrp(*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a2 + 64) + 8i64) + 76i64) + 1, 0);
  v5 = v4;
  if ( v4 )
  {
    v6 = --v4->Tail.Overlay.CurrentStackLocation;
    --v4->CurrentLocation;
    v4->IoStatus.Status = -1073741637;
    memset(v6, 0, sizeof(struct _IO_STACK_LOCATION));
    v6->Parameters.CreatePipe.Parameters = 0i64;
    v6->Parameters.WMI.ProviderId = (ULONG_PTR)&GUID_WDF_HID_INTERFACE_STANDARD;
    *(_WORD *)&v6->MajorFunction = 2075;
    v6->Parameters.Create.Options = 65584;
    v6->Parameters.Read.ByteOffset.QuadPart = (LONGLONG)v3;
    IoForwardIrpSynchronously(*(PDEVICE_OBJECT *)(*(_QWORD *)(a2 + 64) + 8i64), v5);
    if ( v5->IoStatus.Status < 0 )
      memset(v3, 0, 0x30ui64);
    IoFreeIrp(v5);
  }
  *(_DWORD *)(a2 + 48) &= 0xFFFFFF7F;
  return 0i64;
}

//----- (00000001C0006140) ----------------------------------------------------
NTSTATUS __fastcall HidKmdfPnp(__int64 a1, IRP *a2)
{
  struct _IO_STACK_LOCATION *v2; // rax
  _WORD *v5; // rbx

  v2 = a2->Tail.Overlay.CurrentStackLocation;
  *(_OWORD *)&v2[-1].MajorFunction = *(_OWORD *)&v2->MajorFunction;
  *(_OWORD *)&v2[-1].Parameters.NotifyDirectoryEx.CompletionFilter = *(_OWORD *)&v2->Parameters.NotifyDirectoryEx.CompletionFilter;
  *(_OWORD *)(&v2[-1].Parameters.SetQuota + 6) = *(_OWORD *)(&v2->Parameters.SetQuota + 6);
  v2[-1].FileObject = v2->FileObject;
  v2[-1].Control = 0;
  if ( v2->MinorFunction == 2 )
  {
    v5 = *(_WORD **)(*(_QWORD *)(a1 + 64) + 16i64);
    if ( *v5 == 48 && v5[1] == 1 )
    {
      (*((void (__fastcall **)(_QWORD))v5 + 3))(*((_QWORD *)v5 + 1));
      memset(v5, 0, 0x30ui64);
    }
  }
  return IofCallDriver(*(PDEVICE_OBJECT *)(*(_QWORD *)(a1 + 64) + 8i64), a2);
}

//----- (00000001C0007008) ----------------------------------------------------
NTSTATUS __stdcall DriverEntry(_DRIVER_OBJECT *DriverObject, PUNICODE_STRING RegistryPath)
{
  struct _HID_MINIDRIVER_REGISTRATION v3; // [rsp+20h] [rbp-38h] BYREF

  memset64(DriverObject->MajorFunction, (unsigned __int64)HidKmdfPassThrough, 0x1Cui64);
  DriverObject->MajorFunction[22] = (PDRIVER_DISPATCH)HidKmdfPowerPassThrough;
  DriverObject->MajorFunction[27] = (PDRIVER_DISPATCH)HidKmdfPnp;
  DriverObject->DriverExtension->AddDevice = (PDRIVER_ADD_DEVICE)HidKmdfAddDevice;
  *(_QWORD *)&v3.Revision = 1i64;
  DriverObject->DriverUnload = (PDRIVER_UNLOAD)HidKmdfUnload;
  *(_WORD *)v3.Reserved = 0;
  v3.Reserved[2] = 0;
  v3.DriverObject = DriverObject;
  v3.RegistryPath = RegistryPath;
  v3.DeviceExtensionSize = 48;
  v3.DevicesArePolled = 0;
  return HidRegisterMinidriver(&v3);
}
// 1C0006200: using guessed type __int64 __fastcall HidKmdfUnload();

//----- (00000001C00070C0) ----------------------------------------------------
NTSTATUS __stdcall GsDriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)
{
  _security_init_cookie();
  return DriverEntry(DriverObject, RegistryPath);
}

// nfuncs=16 queued=10 decompiled=10 lumina nreq=0 worse=0 better=0
// ALL OK, 10 function(s) have been successfully decompiled
